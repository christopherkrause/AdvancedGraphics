<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf=8" />

    <title>CandleStick</title>

    <style>
        body {
            background-color : #2b3f3d;
            font-family: "Arial Rounded MT Bold", "Helvetica Rounded", Arial, sans-serif;
        }
        h1 {
            font-size : 1.2em;
        }
        footer {
            font-size : 0.7em;
            font-family: "Arial Rounded MT", "Helvetica Rounded", Arial, sans-serif;
            font-style: italic;
        }
    </style>

    <script src="matrix.js"></script>
    <script src="candlestick.js"></script>
    <script src="candle.js"></script>
    <script src="table.js"></script>
    <script src="tray.js"></script>
    <script src="bottle.js"></script>
    <script src="flame.js"></script>

    <script src="cig.png"></script>
    <script src="clear-glass.png"></script>
    <script src="cork.png"></script>
    <script src="label.png"></script>
    <script src="patina.png"></script>
    <script src="wax2.png"></script>
    <script src="wood.png"></script>





    <!-- vertex shader-1 for flame-->
    <script id="vertex-1" type="x-shader">
    attribute vec4 vertexPosition;
    attribute vec3 vertexNormal;
    attribute vec2 vertexTexCoord;

    varying vec4 color;
    varying vec3 rawPosition;

    uniform mat4 ModelViewProjection;
    uniform mat4 ModelViewMatrix;
    uniform mat3 NormalMatrix;

    uniform vec3 ambientLight;
    uniform vec3 light0Color;
    uniform vec3 light0Position;
    uniform vec3 light1Color;
    uniform vec3 light1Position;

  uniform vec3 materialAmbient;
  uniform vec3 materialDiffuse;
  uniform vec3 materialSpecular;
  uniform float materialShininess;

  void main() {
    gl_Position = ModelViewProjection*vertexPosition;
    rawPosition = vertexPosition.xyz;
    vec3 P = vec3(ModelViewMatrix * vertexPosition);

    vec3 N = normalize(NormalMatrix * vertexNormal);
    vec3 V = normalize(-P);
    vec3 I_ambient = materialAmbient * ambientLight;

    vec3 L = normalize(light0Position - P);
    float cos_theta = dot(L,N);
    vec3 I_diffuse = materialDiffuse * light0Color * vec3(max(0.0, cos_theta));
    vec3 I_specular = vec3(0.0, 0.0, 0.0);

    if (cos_theta > 0.0) {
      vec3 R = reflect(-L,N);
      float cos_alpha = dot(R,V);
      I_specular = materialSpecular * light0Color *
        vec3(pow(max(0.0, cos_alpha), materialShininess));
    }

    L = normalize(light1Position - P);
    cos_theta = dot(L,N);
    I_diffuse += materialDiffuse * light1Color * vec3(max(0.0, cos_theta));

    if (cos_theta > 0.0) {
      vec3 R = reflect(-L,N);
      float cos_alpha = dot(R,V);
      I_specular += materialSpecular * light1Color *
        vec3(pow(max(0.0, cos_alpha), materialShininess));
    }

    vec3 I = I_ambient + I_diffuse + I_specular;
    color = vec4(I, 1.0);
  }
</script>

    <script id="vertex" type="x-shader">
   attribute vec4 vertexPosition;
   attribute vec3 vertexNormal;
   attribute vec2 vertexTexCoord;

   varying vec2 texCoord;
   varying vec4 color;

   uniform mat4 ModelViewProjection;
   uniform mat4 ModelViewMatrix;
   uniform mat3 NormalMatrix;

    uniform mat4 TextureMatrix;


   uniform vec3 ambientLight;
   uniform vec3 light0Color;
   uniform vec3 light0Position;

   uniform vec3 materialAmbient;
   uniform vec3 materialDiffuse;
   uniform vec3 materialSpecular;
   uniform float materialShininess;

   void main() {
     gl_Position = ModelViewProjection*vertexPosition;
     texCoord = (TextureMatrix*vec4(vertexTexCoord,0.0,1.0)).st;


     vec3 P = vec3(ModelViewMatrix * vertexPosition);
     vec3 N = normalize(NormalMatrix * vertexNormal);
     vec3 L = normalize(light0Position - P);

     vec3 I_ambient = materialAmbient * ambientLight;
     float cos_theta = dot(L,N);
     vec3 diffuseScale = light0Color * max(0.0, cos_theta);
     vec3 I_diffuse = materialDiffuse * diffuseScale;
     vec3 I_specular = vec3(0.0, 0.0, 0.0);

     if (cos_theta > 0.0) {
       vec3 R = reflect(-L,N);
       vec3 V = normalize(-P);
       float cos_alpha = dot(R,V);
       I_specular = materialSpecular * light0Color *
         pow(max(0.0, cos_alpha), materialShininess);
     }

     color = vec4(I_ambient + I_diffuse + I_specular, 1.0);
   }
</script>

    <script id="fragment" type="x-shader">
      precision mediump float;
      varying vec2 texCoord;
      varying vec4 color;
      uniform sampler2D texUnit;

      void main() {
	  gl_FragColor = texture2D(texUnit, texCoord) * color;
	  	  //gl_FragColor = color;
      }
</script>

    <script id="fragment-1" type="x-shader">
  precision mediump float;
  varying vec4 color;
  varying vec3 rawPosition;

  uniform float time; // XXX

  const vec3 scale = vec3(1.2, 1.2, 1.2);
  //const vec3 scale = vec3(10,10,10);

  float snoise(vec4 v);

  //const int M = 5;

  float turbulance(in vec4 v) {
      vec4 freq = vec4(1.0);
      float sum = 0.0;
      const int M = 3;
      for (int i = 0; i < M; i++) {
	  sum += snoise(freq*v)/freq.x;
          freq -= vec4(2.0);
      }
      return sum;
  }

  const float tau = 0.5;
  const mat4 catmulM = mat4( 0.0, 1.0, 1.0, 0.0,
                            -tau, 0.0, tau, 0.0,
                            2.0*tau, tau-3.0, 3.0 - 2.0*tau, -tau,
                            -tau, 2.0-tau, tau-2.0, tau);

  vec3 colorSpline(float u, in vec3 P, in vec3 P0, in vec3 P1, in vec3 P2) {
    float uu = u*u;
    vec4 U = vec4(1, u, uu, uu*u);
    vec4 V = catmulM*U;
    vec3 color;
    color.r = dot(V,vec4(P.r, P0.r, P1.r, P2.r));
    color.g = dot(V,vec4(P.g, P0.g, P1.g, P2.g));
    color.b = dot(V,vec4(P.b, P0.b, P1.b, P2.b));
    return color;
  }

  void main() {
    vec4 P = vec4(rawPosition*scale,time/60.0);
    float s = sin(snoise(P) + turbulance(P));
    float w = (s + 1.4)/1.8;
    vec3 m = mix(vec3(0.0, 0.0, 0.0), vec3(1, 0.4, 0),w);
    vec3 c = mix(m, vec3(1, 0.9, 0.4),w);
    gl_FragColor = vec4(c*color.xyz,1.0);
  }

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0; }

float mod289(float x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0; }

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

float permute(float x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float taylorInvSqrt(float r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 grad4(float j, vec4 ip)
  {
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;

  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;

  return p;
  }

// (sqrt(5) - 1)/4 = F4, used once below
#define F4 0.309016994374947451

float snoise(vec4 v)
  {
  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                        0.276393202250021,  // 2 * G4
                        0.414589803375032,  // 3 * G4
                       -0.447213595499958); // -1 + 4 * G4

// First corner
  vec4 i  = floor(v + dot(v, vec4(F4)) );
  vec4 x0 = v -   i + dot(i, C.xxxx);

// Other corners

// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
  vec4 i0;
  vec3 isX = step( x0.yzw, x0.xxx );
  vec3 isYZ = step( x0.zww, x0.yyz );
//  i0.x = dot( isX, vec3( 1.0 ) );
  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;
//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;
  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;

  // i0 now contains the unique values 0,1,2,3 in each channel
  vec4 i3 = clamp( i0, 0.0, 1.0 );
  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

  //  x0 = x0 - 0.0 + 0.0 * C.xxxx
  //  x1 = x0 - i1  + 1.0 * C.xxxx
  //  x2 = x0 - i2  + 2.0 * C.xxxx
  //  x3 = x0 - i3  + 3.0 * C.xxxx
  //  x4 = x0 - 1.0 + 4.0 * C.xxxx
  vec4 x1 = x0 - i1 + C.xxxx;
  vec4 x2 = x0 - i2 + C.yyyy;
  vec4 x3 = x0 - i3 + C.zzzz;
  vec4 x4 = x0 + C.wwww;

// Permutations
  i = mod289(i);
  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

  vec4 p0 = grad4(j0,   ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);

// Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));

// Mix contributions from the five corners
  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
  m0 = m0 * m0;
  m1 = m1 * m1;
  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;

}

      </script>
    <script>
        var gl;
        var canvas;
        var program;
        var camera;
        var light0Position;
        var program, program1;

        var Model, View, Projection, Texture;

        function getMousePos(canvas, event) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        var mouseDrag;
        function mouseDown(event) {
            mouseDrag = getMousePos(canvas, event);
        }
        var radiansPerPixel = 0.01;
        var phiMin = -Math.PI/2 + 0.001;
        var phiMax = +Math.PI/2 - 0.001;
        var frame; // current anim frame (undefined => no frame)

        function mouseMove(event) {
            if (mouseDrag) {
                var mousePos = getMousePos(canvas, event);
                var dx = mousePos.x - mouseDrag.x;
                var dy = mousePos.y - mouseDrag.y;
                camera.theta += dx*radiansPerPixel;
                camera.phi += dy*radiansPerPixel;
                if (camera.phi < phiMin)
                    camera.phi = phiMin;
                else if (camera.phi > phiMax)
                    camera.phi = phiMax;
                mouseDrag = mousePos;
                if (!frame)
                    frame = requestAnimationFrame(drawAnimFrame);
            }
        }

        function mouseUp(event) {
            var mousePos = getMousePos(canvas, event);
            mouseDrag = null;
        }

        function init() {
            canvas = document.getElementById("myCanvas");
            gl = null;
            try {
                gl = canvas.getContext("webgl", {preserveDrawingBuffer: true, stencil : true});
            } catch(e) {gl = null;}
            if (gl == null) {
                alert("No WebGL -- bummer!");
                return false;
            }

            canvas.addEventListener("mousedown", mouseDown, false);
            canvas.addEventListener("mousemove", mouseMove, false);
            document.body.addEventListener("mouseup", mouseUp, false);

            /***  vertex shader-1 for flame texture  ***/
            var v1 = document.getElementById("vertex-1").firstChild.nodeValue;
            var vs1 = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs1,v1);
            gl.compileShader(vs1);
            if (!gl.getShaderParameter(vs1,gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(vs1));
                return false;
            }

            /***  fragment shader-1 for flame texture  ***/
            var f1 = document.getElementById("fragment-1").firstChild.nodeValue;
            var fs1 = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs1,f1);
            gl.compileShader(fs1);
            if (!gl.getShaderParameter(fs1,gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(fs1));
                return false;
            }

            var v = document.getElementById("vertex").firstChild.nodeValue;
            var vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs,v);
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs,gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(vs));
                return false;
            }

            var f = document.getElementById("fragment").firstChild.nodeValue;
            var fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs,f);
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs,gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(fs));
                return false;
            }

            /***  Program 1  for flame  ***/

            program1 = gl.createProgram();
            gl.attachShader(program1, vs1);
            gl.attachShader(program1, fs1);
            gl.linkProgram(program1);
            gl.useProgram(program1);
//
            var vertices = new Float32Array(flame.verts);
            flame.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, flame.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(flame.normals);
            flame.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, flame.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(flame.triangleStrip);
            flame.numTriangleStripIndices = indices.length;
            flame.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, flame.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            program1.vertexPosition = gl.getAttribLocation(program1, "vertexPosition");
            program1.vertexNormal = gl.getAttribLocation(program1, "vertexNormal");
            program1.ModelViewProjection = gl.getUniformLocation(program1, "ModelViewProjection");

            program1.ModelViewMatrix = gl.getUniformLocation(program1, "ModelViewMatrix");
            program1.NormalMatrix = gl.getUniformLocation(program1, "NormalMatrix");
            program1.ambientLight = gl.getUniformLocation(program1, "ambientLight");
            program1.light0Color = gl.getUniformLocation(program1, "light0Color");
            program1.light0Position = gl.getUniformLocation(program1, "light0Position");
            program1.materialAmbient = gl.getUniformLocation(program1, "materialAmbient");
            program1.materialDiffuse = gl.getUniformLocation(program1, "materialDiffuse");
            program1.materialSpecular = gl.getUniformLocation(program1, "materialSpecular");
            program1.materialShininess = gl.getUniformLocation(program1, "materialShininess");
//
//
            program1.time = gl.getUniformLocation(program1, "time");

            program1.shader = gl.getUniformLocation(program1, "shader");

            gl.uniform3fv(program1.materialAmbient,[1.0, 0.0, 0.0]);
            gl.uniform3fv(program1.materialDiffuse,[0.0, 0.1, 0.5]);
            gl.uniform3fv(program1.materialSpecular,[1, 1, 1]);
            gl.uniform1f(program1.materialShininess, 0);

            gl.uniform3fv(program1.ambientLight,[0.3, 0.1, 0.3]);
            gl.uniform3fv(program1.light0Color,[1.0, 1.0, 1.0]);
            gl.uniform3fv(program1.light0Position,[10.0, 10.0, 30.0]);

            //gl.disableVertexAttribArray(flame.vertbuffer);


            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            gl.useProgram(program);

            //candlestick buffer
            var vertices = new Float32Array(candlestick.verts);
            candlestick.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candlestick.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(candlestick.normals);
            candlestick.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candlestick.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(candlestick.triangleStrip);
            candlestick.numTriangleStripIndices = indices.length;
            candlestick.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, candlestick.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            candlestick.texCoords = new Float32Array(candlestick.texCoords);
            candlestick.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candlestick.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, candlestick.texCoords, gl.STATIC_DRAW);

            //candle buffer

            var vertices = new Float32Array(candle.verts);
            candle.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candle.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(candle.normals);
            candle.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candle.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(candle.triangleStrip);
            candle.numTriangleStripIndices = indices.length;
            candle.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, candle.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            candle.texCoords = new Float32Array(candle.texCoords);
            candle.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, candle.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, candle.texCoords, gl.STATIC_DRAW);

            //table buffer

            table.texCoords = new Float32Array(table.texCoords);
            table.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, table.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, table.texCoords, gl.STATIC_DRAW);

            var vertices = new Float32Array(table.verts);
            table.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, table.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(candle.normals);
            table.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, table.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(table.triangleStrip);
            table.numTriangleStripIndices = indices.length;
            table.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, table.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            //tray buffer

            var vertices = new Float32Array(bottle.verts);
            bottle.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bottle.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(bottle.normals);
            bottle.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bottle.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(bottle.triangleStrip);
            bottle.numTriangleStripIndices = indices.length;
            bottle.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bottle.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            bottle.texCoords = new Float32Array(bottle.texCoords);
            bottle.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bottle.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, bottle.texCoords, gl.STATIC_DRAW);


            var vertices = new Float32Array(tray.verts);
            tray.vertbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tray.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            var normals = new Float32Array(tray.normals);
            tray.normbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tray.normbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var indices = new Uint16Array(tray.triangleStrip);
            tray.numTriangleStripIndices = indices.length;
            tray.triangleStripBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tray.triangleStripBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            tray.texCoords = new Float32Array(tray.texCoords);
            tray.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tray.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, tray.texCoords, gl.STATIC_DRAW);

            program.vertexPosition = gl.getAttribLocation(program, "vertexPosition");
            program.vertexNormal = gl.getAttribLocation(program, "vertexNormal");

            program.vertexTexCoord = gl.getAttribLocation(program, "vertexTexCoord");
            program.TextureMatrix = gl.getUniformLocation(program, "TextureMatrix");

            program.ModelViewProjection = gl.getUniformLocation(program, "ModelViewProjection");
            program.ModelViewMatrix = gl.getUniformLocation(program, "ModelViewMatrix");
            program.NormalMatrix = gl.getUniformLocation(program, "NormalMatrix");

            program.ambientLight = gl.getUniformLocation(program, "ambientLight");
            program.light0Color = gl.getUniformLocation(program, "light0Color");
            program.light0Position = gl.getUniformLocation(program, "light0Position");
            program.light1Color = gl.getUniformLocation(program, "light1Color");
            program.light1Position = gl.getUniformLocation(program, "light1Position");

            program.materialAmbient = gl.getUniformLocation(program, "materialAmbient");
            program.materialDiffuse = gl.getUniformLocation(program, "materialDiffuse");
            program.materialSpecular = gl.getUniformLocation(program, "materialSpecular");
            program.materialShininess = gl.getUniformLocation(program, "materialShininess");

            program.texUnit = gl.getUniformLocation(program, "texUnit");

            light0Position = [30.0, 30.0, 30.0,0.5];

            gl.uniform3fv(program.ambientLight,[0.2, 0.2, 0.2]);

            gl.uniform3fv(program.light0Color,[1.0, 1.0, 1.0]);
            gl.uniform4fv(program.light0Position,light0Position);
            gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
            gl.uniform3fv(program.materialDiffuse,[1.0, 1.0, 1.0]);
            gl.uniform3fv(program.materialSpecular,[0.5, 0.5, 0.5]);
            gl.uniform1f(program.materialShininess, 20.0);

            gl.clearColor(0.2,0.2,0.2,1);

            gl.uniform1i(program.texUnit, 0);

            var loadTexture = function(texUnit, imageName) {
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, program.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                        new Uint8Array([0, 0, 0, 255])); // red
                var textureImage = new Image();
                textureImage.src = imageName;
                textureImage.onload = function() {
                    var isPowerOfTwo = function(value) {
                        return (value & (value - 1)) == 0;
                    }
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); only needed for some textures
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE,
                           textureImage);
                    if (isPowerOfTwo(textureImage.width) && isPowerOfTwo(textureImage.height)) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                        gl.generateMipmap(gl.TEXTURE_2D);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                                gl.LINEAR_MIPMAP_LINEAR);
                    } else {  // NPOT
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    }
                    frame = requestAnimationFrame(display);
                }
                return texture;
            }

            program.candlesticktexture = loadTexture(gl.TEXTURE0, "patina.png");
            program.tabletexture = loadTexture(gl.TEXTURE1, "wood.png")
            program.candletexture = loadTexture(gl.TEXTURE2, "wax2.png");
            program.traytexture = loadTexture(gl.TEXTURE2, "black.png");
            program.cigarettetexture = loadTexture(gl.TEXTURE2, "cig.png");
            program.bottletexture = loadTexture(gl.TEXTURE2, "clear-glass.png");
            program.corktexture = loadTexture(gl.TEXTURE2, "cork.png");
            program.labeltexture = loadTexture(gl.TEXTURE2, "label.png");

            Projection = new Matrix4x4;
            Projection.perspective(40, 1, 0.1, 100);

            View = new Matrix4x4;
            Model = new Matrix4x4;
            Texture = new Matrix4x4();

            camera = {};
            camera.lookat = {x : 1, y : 1, z : 2.5};
            camera.distance = 25;
            camera.phi = Math.PI/6;
            camera.theta = Math.PI/4;

            gl.viewport(0,0,canvas.width,canvas.height);

            gl.enable(gl.DEPTH_TEST);
            gl.frontFace(gl.CCW);
            //gl.enable(gl.CULL_FACE);
            //gl.lineWidth(2.0);
        }

        function getCameraPosition() {
            var d_cos_phi = camera.distance*Math.cos(camera.phi);
            camera.x = d_cos_phi*Math.sin(camera.theta) + camera.lookat.x;
            camera.y = d_cos_phi*Math.cos(camera.theta) + camera.lookat.y;
            camera.z = camera.distance*Math.sin(camera.phi) + camera.lookat.z;
        }

        function drawPolyTriangles1(poly) {

            gl.bindBuffer(gl.ARRAY_BUFFER, poly.vertbuffer);
            gl.enableVertexAttribArray(program1.vertexPosition);
            gl.vertexAttribPointer(program1.vertexPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, poly.normbuffer);
            gl.enableVertexAttribArray(program1.vertexNormal);
            gl.vertexAttribPointer(program1.vertexNormal, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, flame.triangleStripBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, poly.numTriangleStripIndices,
                    gl.UNSIGNED_SHORT, 0);

        }

        function drawPolyTriangles(poly) {
            gl.bindBuffer(gl.ARRAY_BUFFER, poly.vertbuffer);
            gl.enableVertexAttribArray(program.vertexPosition);
            gl.vertexAttribPointer(program.vertexPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, poly.normbuffer);
            gl.enableVertexAttribArray(program.vertexNormal);
            gl.vertexAttribPointer(program.vertexNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, poly.texCoordBuffer);
            gl.enableVertexAttribArray(program.vertexTexCoord);
            gl.vertexAttribPointer(program.vertexTexCoord, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, poly.triangleStripBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, poly.numTriangleStripIndices,
                    gl.UNSIGNED_SHORT, 0);
        }

        function loadUniforms(mat) {
            var NormalMatrix = mat.normal();
            var MVP = Projection.mult(mat);
            gl.uniformMatrix4fv(program.ModelViewProjection, false, MVP.array);
            gl.uniformMatrix4fv(program.ModelViewMatrix, false, mat.array);
            gl.uniformMatrix3fv(program.NormalMatrix, false, NormalMatrix);
            gl.uniformMatrix4fv(program.TextureMatrix, false, Texture.array);
        }

        function loadUniforms1(mat) {
            var NormalMatrix = mat.normal();
            var MVP = Projection.mult(mat);
            gl.uniformMatrix4fv(program1.ModelViewProjection, false, MVP.array);
            gl.uniformMatrix4fv(program1.ModelViewMatrix, false, mat.array);
            gl.uniformMatrix3fv(program1.NormalMatrix, false, NormalMatrix);

        }

        function display() {
            frame = undefined;
            var matrixStack = new Matrix4x4Stack();

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

            getCameraPosition();

            View.identity();
            View.lookat(camera.x, camera.y, camera.z,
                    camera.lookat.x, camera.lookat.y, camera.lookat.z,
                    0, 0, 1);

            var ViewInverse = new Matrix4x4();
            ViewInverse.inverseLookat(camera.x, camera.y, camera.z, camera.lookat.x,
                    camera.lookat.y, camera.lookat.z, 0, 0, 1);

            var ModelView = View.mult(Model);
            var NormalMatrix = ModelView.normal();
            var MVP = Projection.mult(ModelView);

            gl.uniformMatrix4fv(program.ModelViewProjection, false, MVP.array);
            gl.uniformMatrix4fv(program.ModelViewMatrix, false, ModelView.array);
            gl.uniformMatrix3fv(program.NormalMatrix, false, NormalMatrix);

            //gl.useProgram(program1);
            //function for loading candle
            function loadCandle(shift, shift2){

//                matrixStack.push(ModelView);
//                gl.useProgram(program1);
//                gl.uniformMatrix4fv(program1.ModelViewProjection, false, MVP.array);
//                gl.uniformMatrix4fv(program1.ModelViewMatrix, false, ModelView.array);
//                gl.uniformMatrix3fv(program1.NormalMatrix, false, NormalMatrix);
//                ModelView.translate(0, 0, shift2+3);
//                ModelView.scale(0.6, 0.6, 0.7);
//                loadUniforms1(ModelView);
//                drawPolyTriangles1(flame);
//                matrixStack.pop(ModelView);


                gl.useProgram(program);
                matrixStack.push(ModelView);
                ModelView.translate(0, 0, shift2);
                //ModelView.scale(0.1, 0.1, 1.18);
                ModelView.scale(0.1, 0.1, 1.18);
                loadUniforms(ModelView);
                drawPolyTriangles(candle);
                matrixStack.pop(ModelView);

                gl.uniform3fv(program.materialAmbient,[0.9, 0.9, 0.9]);
                gl.uniform3fv(program.materialDiffuse,[1, 1, 1]);
                gl.uniform3fv(program.materialSpecular,[0, 0, 0]);
                gl.uniform1f(program.materialShininess,15.0);
                gl.bindTexture(gl.TEXTURE_2D, program.candletexture);
                matrixStack.push(ModelView);
                ModelView.translate(0, 0, shift2);
                loadUniforms(ModelView);
                drawPolyTriangles(candle);
                matrixStack.pop(ModelView);

                gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
                gl.uniform3fv(program.materialDiffuse,[1, 1, 1]);
                gl.uniform3fv(program.materialSpecular,[1, 1, 1]);
                gl.uniform1f(program.materialShininess,15.0);
                gl.bindTexture(gl.TEXTURE_2D, program.candlesticktexture);
                matrixStack.push(ModelView);
                ModelView.translate(0,0,shift);
                loadUniforms(ModelView);
                drawPolyTriangles(candlestick);
                matrixStack.pop(ModelView);
            }
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.STENCIL_TEST);
            gl.disable(gl.BLEND);
            gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
            gl.uniform3fv(program.materialDiffuse,[1, 1, 1]);
            gl.uniform3fv(program.materialSpecular,[0.1, 0.1, 0.1]);
            gl.uniform1f(program.materialShininess,15.0);
            loadCandle(0.1, 3.7);

            function loadashTray(){

                gl.bindTexture(gl.TEXTURE_2D, program.traytexture);
                matrixStack.push(ModelView);
                ModelView.translate(0, 5, 0.1);
                loadUniforms(ModelView);
                drawPolyTriangles(tray);
                matrixStack.pop(ModelView);

                //cigarette

                gl.bindTexture(gl.TEXTURE_2D, program.cigarettetexture);
                matrixStack.push(ModelView);
                ModelView.translate(-0.5, 4.6, 0.9);
                ModelView.rotate(100, -1, 1, 1);
                ModelView.scale(0.3, 0.3, 1);
                loadUniforms(ModelView);
                drawPolyTriangles(candle); //reuse the candle
                matrixStack.pop(ModelView);
            }
//
            gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
            gl.uniform3fv(program.materialDiffuse,[1, 1, 1]);
            gl.uniform3fv(program.materialSpecular,[0.1, 0.1, 0.1]);
            gl.uniform1f(program.materialShininess,15.0);
            matrixStack.push(ModelView);
            loadashTray();
            matrixStack.pop(ModelView);


            function loadbottle(){
                //label
                gl.uniform3fv(program.materialSpecular,[0, 0, 0]);
                gl.bindTexture(gl.TEXTURE_2D, program.labeltexture);
                matrixStack.push(ModelView)
                gl.bindTexture(gl.TEXTURE_2D, program.labeltexture);
                ModelView.translate(7, 2, 2);
                ModelView.scale(2.51, 2.51, 1.1);
                loadUniforms(ModelView);
                drawPolyTriangles(candle); //reuse the candle
                matrixStack.pop(ModelView);

                //cork
                gl.uniform3fv(program.materialSpecular,[0, 0, 0]);
                gl.bindTexture(gl.TEXTURE_2D, program.corktexture);
                matrixStack.push(ModelView);
                ModelView.translate(7, 2, 8.3);
                ModelView.scale(0.45, 0.45, 1);
                loadUniforms(ModelView);
                drawPolyTriangles(candle); //reuse the candle
                matrixStack.pop(ModelView);

                gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
                gl.uniform3fv(program.materialDiffuse,[0.2, 0.8, 0.1]);
                gl.uniform3fv(program.materialSpecular,[1, 1, 1]);
                gl.uniform1f(program.materialShininess,15.0);
                gl.bindTexture(gl.TEXTURE_2D, program.bottletexture);
                matrixStack.push(ModelView);
                ModelView.translate(7, 2, 0.1);
                ModelView.scale(10, 10, 10);
                loadUniforms(ModelView);
                drawPolyTriangles(bottle);
                matrixStack.pop(ModelView);

                gl.uniform3fv(program.materialAmbient,[0.3, 0.3, 0.3]);
                gl.uniform3fv(program.materialDiffuse,[0.25, 0, 0.1]);
                gl.uniform3fv(program.materialSpecular,[0.6, 0.6, 0.6]);
                gl.uniform1f(program.materialShininess,40.0);
                matrixStack.push(ModelView);
                ModelView.translate(7, 2, 0.1);
                ModelView.scale(2.505, 2.505, 2.2);
                loadUniforms(ModelView);
                drawPolyTriangles(candle); //reuse the candle
                matrixStack.pop(ModelView);
            }
            loadbottle();

            function loadFlame(){
//                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
//                gl.enable(gl.BLEND);
//                gl.disable(gl.DEPTH_TEST);
                matrixStack.push(ModelView);
                //gl.clearColor()
                gl.useProgram(program1);
                gl.uniformMatrix4fv(program1.ModelViewProjection, false, MVP.array);
                gl.uniformMatrix4fv(program1.ModelViewMatrix, false, ModelView.array);
                gl.uniformMatrix3fv(program1.NormalMatrix, false, NormalMatrix);
                ModelView.translate(0, 0, 6.4);
                ModelView.scale(0.6, 0.6, 0.7);
                loadUniforms1(ModelView);
                drawPolyTriangles1(flame);
                matrixStack.pop(ModelView);
            }
            loadFlame();
//
//            gl.disable(gl.BLEND);
//            gl.enable(gl.DEPTH_TEST);


            gl.enable(gl.STENCIL_TEST);   // WOC : draw table, record visible table in stencil
            gl.stencilFunc(gl.ALWAYS, 1, 1);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

            gl.useProgram(program);
            gl.uniform3fv(program.materialAmbient,[0.9, 0.9, 0.9]);
            gl.uniform3fv(program.materialDiffuse,[0.3, 0.3, 0.3]);
            gl.uniform3fv(program.materialSpecular,[0.9, 0.9, 0.9]);
            gl.uniform1f(program.materialShininess,30.0);


            gl.bindTexture(gl.TEXTURE_2D, program.tabletexture);
            matrixStack.push(ModelView);
            //ModelView.translate(0,0,0);
            ModelView.scale(5,5,5);
            loadUniforms(ModelView);
            drawPolyTriangles(table);
            matrixStack.pop(ModelView);
            gl.useProgram(program1);

            /*****Draw reflection******/

            gl.clear(gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            //gl.frontFace(gl.CCW);
            //gl.enable(gl.CULL_FACE);

            gl.stencilFunc(gl.EQUAL, 1, 1);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

            matrixStack.push(ModelView);
            var Reflect = new Matrix4x4().scale(1, 1, -1);
            ModelView.concat(Reflect);


            var lightReflected = View.mult(Reflect.mult(ViewInverse)).transform(light0Position);
            /** This breaks my program. Tried to reflect the light but Im sure its a
             * little off. **/
            //gl.uniform4vf(program.light0Position, lightReflected);

            gl.useProgram(program);
            var ModelView = View.mult(Model);
            var NormalMatrix = ModelView.normal();
            var MVP = Projection.mult(ModelView);
            gl.uniformMatrix4fv(program.ModelViewProjection, false, MVP.array);
            gl.uniformMatrix4fv(program.ModelViewMatrix, false, ModelView.array);
            gl.uniformMatrix3fv(program.NormalMatrix, false, NormalMatrix);
            gl.uniform3fv(program.materialAmbient,[0.6, 0.6, 0.6]);
            gl.uniform3fv(program.materialDiffuse,[1.0, 1.0, 1.0]);
            gl.uniform3fv(program.materialSpecular,[1.0, 1.0, 1.0]);
            gl.uniform1f(program.materialShininess,15.0);

            ModelView.scale(1, 1, -1);
            loadUniforms(ModelView);
            loadCandle(0.01, 3.7);
            loadashTray();
            loadbottle();
            gl.useProgram(program1);
            loadFlame();


            matrixStack.pop(ModelView);
            gl.disable(gl.POLYGON_OFFSET_FILL);

            gl.enable(gl.BLEND);
            gl.blendColor(1,1,1,0.7);
            gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA);

            gl.useProgram(program);
            gl.bindTexture(gl.TEXTURE_2D, program.tabletexture);
            gl.uniform3fv(program.materialAmbient,[0.9, 0.9, 0.9]);
            gl.uniform3fv(program.materialDiffuse,[0.3, 0.3, 0.3]);
            gl.uniform3fv(program.materialSpecular,[0.9, 0.9, 0.9]);
            gl.uniform1f(program.materialShininess,30.0);
            matrixStack.push(ModelView);
            ModelView.translate(0,0,0);
            ModelView.scale(6,6,6);
            loadUniforms(ModelView);
            drawPolyTriangles(table);
            matrixStack.pop(ModelView);

            /*****Draw shadow******/

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.CONSTANT_COLOR, gl.DST_COLOR);
            gl.blendColor(0,0,0, 0.7);
            gl.stencilFunc(gl.EQUAL, 1,1);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.ZERO);

            matrixStack.push(ModelView);
            var L = ViewInverse.transform([-5.0, 2.0, -5.0, 1.0]);
            ModelView.shadow(L, [0, 0, 1, 0]);
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(-1.0, -1.0);
            loadCandle(0.00, 3.7);
            loadashTray();
            loadbottle();
            gl.disable(gl.POLYGON_OFFSET_FILL);
            matrixStack.pop(ModelView);

            gl.useProgram(program1);
            gl.flush();
        }

        var animationStartTime;

        function drawAnimFrame(currentTime) {
            requestAnimationFrame(drawAnimFrame);
            if (animationStartTime === undefined)
                animationStartTime = currentTime;
            var elapsedTime = (currentTime - animationStartTime) / 10;
            gl.uniform1f(program1.time, elapsedTime);
            display();
        }
    </script>

</head>
<body onload="init(); display()">

<h1>Reflection and Shadows</h1>

<canvas id="myCanvas" width="500" height="500"></canvas><br />
Click and drag to rotate...
refresh your screen if it gets too laggy.
<hr>
<footer>
    Christopher Krause<br />
    December 4, 2016
</footer>

</body>
</html>

